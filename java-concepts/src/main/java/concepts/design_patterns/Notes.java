package concepts.design_patterns;

public class Notes {
	
/*
 
Design Patterns
=================

1.Creational Design Pattern
Factory Pattern
Abstract Factory Pattern
Singleton Pattern
Prototype Pattern
Builder Pattern

2. Structural Design Pattern

-Facade Pattern
    https://refactoring.guru/design-patterns/facade

Proxy Pattern
Flyweight Pattern

Decorator Pattern
Adapter Pattern
Bridge Pattern
Composite Pattern



3. Behavioral Design Pattern

Strategy Pattern
Observer Pattern
Chain Of Responsibility Pattern
Command Pattern
Interpreter Pattern
Iterator Pattern
Mediator Pattern
Memento Pattern
State Pattern
Template Pattern
Visitor Pattern


Facade
---------
A facade encapsulates a complex subsystem behind a simple interface. It hides much of the complexity and makes the subsystem easy to use.
Also, if we need to use the complex subsystem directly, we still can do that; we aren't forced to use the facade all the time.

Flyweight
---------------

flyweight pattern is based on a factory which r created objects by storing them after creation. Each time an object is requested, the factory looks up the object in order to check if it's already been created. If it has, the existing object is returned – otherwise, a new one is created, stored and then returned.

The Flyweight pattern is used to minimize the memory usage by sharing as much data as possible with other similar objects.
The Flyweight pattern provides a way to reduce the number of objects created and to decrease memory footprint and increase performance.

To apply flyweight pattern, we need to divide Object property into intrinsic and extrinsic properties. Intrinsic properties make the Object unique whereas extrinsic properties are set by client code and used to perform different operations. For example, an Object Circle can have extrinsic properties such as color and width. For applying flyweight pattern, we need to create a Flyweight factory that returns the shared objects

Ex- java.lang.Integer#valueOf(int) , Boolean, Byte, Character, Short, Long and BigDecimal



Strategy Design Pattern
------------------------------
Strategy pattern is used when we have multiple algorithm for a specific task and client decides the actual implementation to be used at runtime.


Proxy
---------
-A proxy is placeholder for another object that provide controlled control access to the object.
-Proxy design pattern common uses are to control access or to provide a wrapper implementation for better performance
-we can use it when we need to add some additional behaviors to an object of some existing class without changing the client code. 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 */
	
	
	
	
	

}
